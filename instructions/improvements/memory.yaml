memories:
  - task: "feat/ring-buffer-package"
    date: "2025-12-16"
    context: |
      Created a platform-agnostic ring buffer package following contract-port architecture.
      The user requested all data types be injectable by the host platform, which led to
      designing a storage abstraction (RingBufferStorage, RingBufferStorageFactory) that
      allows hosts to inject their own backing store implementations.
    learnings:
      - type: "pattern"
        summary: "Platform-agnostic data structures should inject storage, not just element types"
        detail: |
          For true platform agnosticism in data structures like ring buffers, inject the
          storage mechanism itself via a factory pattern, not just generic element types.

          GOOD:
          ```typescript
          interface RingBufferStorage<T> {
            get(index: number): T | undefined;
            set(index: number, value: T): void;
          }

          interface RingBufferStorageFactory<T> {
            create(capacity: number): RingBufferStorage<T>;
          }

          function createRingBuffer<T>(deps: { storageFactory: RingBufferStorageFactory<T> }, options: { capacity: number })
          ```

          This allows hosts to provide:
          - Standard JavaScript arrays
          - TypedArrays for numeric data (Uint8Array, Float32Array, etc.)
          - Custom memory-efficient implementations

          BAD: Only making the element type generic without abstracting storage.

      - type: "insight"
        summary: "Unreachable defensive branches hurt test coverage and add noise"
        detail: |
          When coverage reports show an uncovered branch that can't actually be reached
          (e.g., `if (item !== undefined)` when iterating only over written positions),
          remove the defensive check and use a type assertion with a comment instead.

          BEFORE (92.85% branch coverage):
          ```typescript
          const item = storage.get(index);
          if (item !== undefined) {
            result.push(item);
          }
          ```

          AFTER (100% branch coverage):
          ```typescript
          // Safe to cast: we only iterate over indices that were written via push()
          result.push(storage.get(index) as T);
          ```

          The comment explains why the assertion is safe, and we eliminate dead code.

      - type: "command-correction"
        summary: "verify.sh test stage can fail with sandbox EPERM errors"
        detail: |
          WRONG: Running `./verify.sh --ui=false` in sandbox mode when vitest needs
          to create temp directories outside /tmp/claude/.

          Error: EPERM: operation not permitted, mkdir '/tmp/UztX_RCtg0ACh4EcI6p4E/ssr'

          RIGHT: Run with `dangerouslyDisableSandbox: true` when verify.sh fails with
          permission errors. The sandbox restricts writes to /tmp but vitest creates
          temp directories with random names in /tmp directly.

          This is expected behavior - the sandbox is working correctly, but some tools
          need broader temp file access.
