memories:
  - task: "vitest-configs-coverage"
    date: "2025-12-15"
    context: |
      Added vitest.config.ts files to 5 port packages that had tests but were
      missing coverage configuration. This enforces 100% test coverage thresholds
      across all testable packages.
    learnings:
      - type: "pattern"
        summary: "Port packages with tests need vitest.config.ts with 100% coverage"
        detail: |
          Every port package that has tests (*.test.ts files) should have its own
          vitest.config.ts that enforces 100% coverage thresholds:
          - lines: 100
          - functions: 100
          - branches: 100
          - statements: 100

          Template:
          ```typescript
          import { defineConfig } from 'vitest/config';

          export default defineConfig({
            test: {
              coverage: {
                provider: 'v8',
                reporter: ['text', 'lcov'],
                include: ['src/**/*.ts'],
                exclude: ['src/**/*.test.ts'],
                thresholds: {
                  lines: 100,
                  functions: 100,
                  branches: 100,
                  statements: 100,
                },
              },
            },
          });
          ```

      - type: "insight"
        summary: "Find test files first, then check for missing vitest configs"
        detail: |
          When auditing test coverage configs:
          1. Find all test files: `find packages -name "*.test.ts"`
          2. Find all vitest configs: `packages/*/vitest.config.ts`
          3. Diff to find packages with tests but no config

          This task found 6 packages with tests but only 1 had a vitest config.

      - type: "command-correction"
        summary: "git reset --hard origin/main to resolve divergent branches"
        detail: |
          When local main diverges from origin/main after a PR merge (because
          local had unpushed commits that got squashed into the PR), use:

          ```bash
          git reset --hard origin/main
          ```

          This discards the local unpushed commits and aligns with the merged state.

  - task: "vitest-4.0.15-upgrade"
    date: "2025-12-15"
    context: |
      Upgraded vitest from ^2.1.8/^3.0.4 to ^4.0.15 across 8 packages. Also updated
      @vitest/coverage-v8 to match. Major version bump from v2/v3 to v4 worked
      smoothly with no breaking changes in test code.
    learnings:
      - type: "command-correction"
        summary: "Use npm registry curl when npm view fails with permission errors"
        detail: |
          When npm view fails due to cache permission errors:
          ```
          npm error Your cache folder contains root-owned files...
          ```

          Use curl directly to the npm registry instead:
          ```bash
          curl -s https://registry.npmjs.org/vitest/latest | grep -o '"version":"[^"]*"'
          ```

          This bypasses the local npm cache entirely.

      - type: "pattern"
        summary: "Keep @vitest/coverage-v8 version in sync with vitest"
        detail: |
          When updating vitest, ensure @vitest/coverage-v8 is updated to the same
          version. These packages are released together and should match.

          Before: vitest ^3.0.4, @vitest/coverage-v8 ^3.0.4
          After:  vitest ^4.0.15, @vitest/coverage-v8 ^4.0.15

      - type: "insight"
        summary: "Major vitest upgrades (2â†’4) work smoothly for basic test setups"
        detail: |
          Vitest major version upgrades from v2/v3 to v4 required no changes to test
          code. The 242 tests across 8 packages all passed without modification.
          This suggests vitest maintains good backwards compatibility for standard
          test patterns (describe, it, expect, vi.fn, vi.spyOn).

  - task: "feat/doctor-stage"
    date: "2025-12-15"
    context: |
      Added a new "doctor" stage to the verification pipeline that applies
      auto-corrections. First doctor step uses knip to detect unused dependencies.
      Learned important lessons about knip configuration and package-lock.json stability.
    learnings:
      - type: "command-correction"
        summary: "Use knip --dependencies to avoid removing exports"
        detail: |
          WRONG: `knip --fix` - removes all unused exports, breaking the codebase
          RIGHT: `knip --fix --dependencies` - only handles dependency issues

          By default, knip --fix removes unused exports across the codebase, which
          can break intentionally exported APIs. Use --dependencies flag to limit
          scope to dependency issues only.

      - type: "pattern"
        summary: "Keep knip as a devDependency of validation-pipeline, not root"
        detail: |
          knip is a validation concern, not a project-wide tooling concern.
          Placing it in apps/validation-pipeline/package.json keeps responsibilities
          clear. The knip.json config file stays at root to scan the whole monorepo.

      - type: "command-correction"
        summary: "Use main's package-lock.json when npm install breaks types"
        detail: |
          When vitest types break (e.g., ".not does not exist on Assertion<T>"),
          the issue is often a package-lock.json mismatch. Fix by:

          ```bash
          rm -rf node_modules package-lock.json
          git checkout main -- package-lock.json
          npm install
          ```

          This restores the known-good dependency resolution from main.

      - type: "pattern"
        summary: "Add shell-script-only dependencies to knip ignoreDependencies"
        detail: |
          Dependencies used only in shell scripts (like tsx in verify.sh) won't be
          detected by knip's TypeScript analysis. Add them to knip.json:

          ```json
          "ignoreDependencies": ["tsx"]
          ```

      - type: "insight"
        summary: "Headless reporter should output errors for failed stages"
        detail: |
          The headless reporter was only outputting PASS/FAIL without error details.
          Added error output to reportStageResult to show what actually failed:

          ```typescript
          if (result.errors && result.errors.length > 0) {
            for (const error of result.errors) {
              console.log(`  ${error}`);
            }
          }
          ```

  - task: "feat/control-flow-package"
    date: "2025-12-15"
    context: |
      Implemented control flow primitives as two packages: contract-control-flow (pure types)
      and port-control-flow (runtime implementations). Initial implementation had runtime code
      in the contract package, which violated coding-patterns skill guidance. Restructured to
      properly separate concerns.
    learnings:
      - type: "misconception"
        summary: "Contract packages must have NO runtime code - not even error classes"
        detail: |
          WRONG: Putting error classes, helper functions, constants in contract packages
          RIGHT: Contracts contain ONLY TypeScript types, interfaces, type aliases

          The initial contract-control-flow had:
          - Classes (ConveauxError, FetchError, etc.)
          - Functions (ok, err, map, computeRetryDelay, etc.)
          - Constants (DEFAULT_RETRY_METADATA, EXIT_SUCCESS, etc.)

          All of these emit JavaScript and belong in the PORT package, not the contract.

          The rule from coding-patterns: "If it emits JavaScript, it doesn't belong in a contract."

      - type: "pattern"
        summary: "Use 'declare const' for symbols in contracts to define type without value"
        detail: |
          When a contract needs to reference a symbol (like EXIT_CODE), use TypeScript's
          ambient declaration syntax:

          ```typescript
          // In contract (no runtime value)
          export declare const EXIT_CODE: unique symbol;

          // In port (actual runtime value)
          export const EXIT_CODE: typeof import('@conveaux/contract-control-flow').EXIT_CODE =
            Symbol.for('conveaux.exitCode') as typeof import('@conveaux/contract-control-flow').EXIT_CODE;
          ```

          This allows the contract to define the type while the port provides the implementation.

      - type: "pattern"
        summary: "Use timestamps (number) instead of Date objects in contracts"
        detail: |
          WRONG: `retryAfter?: Date` - requires Date constructor, not hermetic
          RIGHT: `retryAfterMs?: number` - pure data, no runtime dependencies

          For FetchError.rateLimited(), accept the timestamp directly:
          ```typescript
          static rateLimited(retryAfterMs?: number): FetchError
          ```

          Callers with access to a clock port compute: `nowMs + delaySeconds * 1000`
          This keeps the contract hermetic (no global Date usage).

      - type: "insight"
        summary: "tsc-reviewer subagent provides thorough automated review"
        detail: |
          The tsc-reviewer subagent performed a comprehensive review covering:
          - Architecture (contract/port separation)
          - Security (no secrets, injection risks)
          - Correctness (logic verification, edge cases)
          - Maintainability (readability, test coverage)
          - Type safety (no any types)

          Verdict was APPROVED with no blockers. This demonstrates the subagent
          can handle rigorous PR review autonomously as required by coding-loop skill.
