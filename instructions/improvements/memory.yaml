memories:
  - task: "vitest-configs-coverage"
    date: "2025-12-15"
    context: |
      Added vitest.config.ts files to 5 port packages that had tests but were
      missing coverage configuration. This enforces 100% test coverage thresholds
      across all testable packages.
    learnings:
      - type: "pattern"
        summary: "Port packages with tests need vitest.config.ts with 100% coverage"
        detail: |
          Every port package that has tests (*.test.ts files) should have its own
          vitest.config.ts that enforces 100% coverage thresholds:
          - lines: 100
          - functions: 100
          - branches: 100
          - statements: 100

          Template:
          ```typescript
          import { defineConfig } from 'vitest/config';

          export default defineConfig({
            test: {
              coverage: {
                provider: 'v8',
                reporter: ['text', 'lcov'],
                include: ['src/**/*.ts'],
                exclude: ['src/**/*.test.ts'],
                thresholds: {
                  lines: 100,
                  functions: 100,
                  branches: 100,
                  statements: 100,
                },
              },
            },
          });
          ```

      - type: "insight"
        summary: "Find test files first, then check for missing vitest configs"
        detail: |
          When auditing test coverage configs:
          1. Find all test files: `find packages -name "*.test.ts"`
          2. Find all vitest configs: `packages/*/vitest.config.ts`
          3. Diff to find packages with tests but no config

          This task found 6 packages with tests but only 1 had a vitest config.

      - type: "command-correction"
        summary: "git reset --hard origin/main to resolve divergent branches"
        detail: |
          When local main diverges from origin/main after a PR merge (because
          local had unpushed commits that got squashed into the PR), use:

          ```bash
          git reset --hard origin/main
          ```

          This discards the local unpushed commits and aligns with the merged state.

  - task: "vitest-4.0.15-upgrade"
    date: "2025-12-15"
    context: |
      Upgraded vitest from ^2.1.8/^3.0.4 to ^4.0.15 across 8 packages. Also updated
      @vitest/coverage-v8 to match. Major version bump from v2/v3 to v4 worked
      smoothly with no breaking changes in test code.
    learnings:
      - type: "command-correction"
        summary: "Use npm registry curl when npm view fails with permission errors"
        detail: |
          When npm view fails due to cache permission errors:
          ```
          npm error Your cache folder contains root-owned files...
          ```

          Use curl directly to the npm registry instead:
          ```bash
          curl -s https://registry.npmjs.org/vitest/latest | grep -o '"version":"[^"]*"'
          ```

          This bypasses the local npm cache entirely.

      - type: "pattern"
        summary: "Keep @vitest/coverage-v8 version in sync with vitest"
        detail: |
          When updating vitest, ensure @vitest/coverage-v8 is updated to the same
          version. These packages are released together and should match.

          Before: vitest ^3.0.4, @vitest/coverage-v8 ^3.0.4
          After:  vitest ^4.0.15, @vitest/coverage-v8 ^4.0.15

      - type: "insight"
        summary: "Major vitest upgrades (2→4) work smoothly for basic test setups"
        detail: |
          Vitest major version upgrades from v2/v3 to v4 required no changes to test
          code. The 242 tests across 8 packages all passed without modification.
          This suggests vitest maintains good backwards compatibility for standard
          test patterns (describe, it, expect, vi.fn, vi.spyOn).

  - task: "feat/doctor-stage"
    date: "2025-12-15"
    context: |
      Added a new "doctor" stage to the verification pipeline that applies
      auto-corrections. First doctor step uses knip to detect unused dependencies.
      Learned important lessons about knip configuration and package-lock.json stability.
    learnings:
      - type: "command-correction"
        summary: "Use knip --dependencies to avoid removing exports"
        detail: |
          WRONG: `knip --fix` - removes all unused exports, breaking the codebase
          RIGHT: `knip --fix --dependencies` - only handles dependency issues

          By default, knip --fix removes unused exports across the codebase, which
          can break intentionally exported APIs. Use --dependencies flag to limit
          scope to dependency issues only.

      - type: "pattern"
        summary: "Keep knip as a devDependency of validation-pipeline, not root"
        detail: |
          knip is a validation concern, not a project-wide tooling concern.
          Placing it in apps/validation-pipeline/package.json keeps responsibilities
          clear. The knip.json config file stays at root to scan the whole monorepo.

      - type: "command-correction"
        summary: "Use main's package-lock.json when npm install breaks types"
        detail: |
          When vitest types break (e.g., ".not does not exist on Assertion<T>"),
          the issue is often a package-lock.json mismatch. Fix by:

          ```bash
          rm -rf node_modules package-lock.json
          git checkout main -- package-lock.json
          npm install
          ```

          This restores the known-good dependency resolution from main.

      - type: "pattern"
        summary: "Add shell-script-only dependencies to knip ignoreDependencies"
        detail: |
          Dependencies used only in shell scripts (like tsx in verify.sh) won't be
          detected by knip's TypeScript analysis. Add them to knip.json:

          ```json
          "ignoreDependencies": ["tsx"]
          ```

      - type: "insight"
        summary: "Headless reporter should output errors for failed stages"
        detail: |
          The headless reporter was only outputting PASS/FAIL without error details.
          Added error output to reportStageResult to show what actually failed:

          ```typescript
          if (result.errors && result.errors.length > 0) {
            for (const error of result.errors) {
              console.log(`  ${error}`);
            }
          }
          ```

  - task: "feat/control-flow-package"
    date: "2025-12-15"
    context: |
      Implemented control flow primitives as two packages: contract-control-flow (pure types)
      and port-control-flow (runtime implementations). Initial implementation had runtime code
      in the contract package, which violated coding-patterns skill guidance. Restructured to
      properly separate concerns.
    learnings:
      - type: "misconception"
        summary: "Contract packages must have NO runtime code - not even error classes"
        detail: |
          WRONG: Putting error classes, helper functions, constants in contract packages
          RIGHT: Contracts contain ONLY TypeScript types, interfaces, type aliases

          The initial contract-control-flow had:
          - Classes (ConveauxError, FetchError, etc.)
          - Functions (ok, err, map, computeRetryDelay, etc.)
          - Constants (DEFAULT_RETRY_METADATA, EXIT_SUCCESS, etc.)

          All of these emit JavaScript and belong in the PORT package, not the contract.

          The rule from coding-patterns: "If it emits JavaScript, it doesn't belong in a contract."

      - type: "pattern"
        summary: "Use 'declare const' for symbols in contracts to define type without value"
        detail: |
          When a contract needs to reference a symbol (like EXIT_CODE), use TypeScript's
          ambient declaration syntax:

          ```typescript
          // In contract (no runtime value)
          export declare const EXIT_CODE: unique symbol;

          // In port (actual runtime value)
          export const EXIT_CODE: typeof import('@conveaux/contract-control-flow').EXIT_CODE =
            Symbol.for('conveaux.exitCode') as typeof import('@conveaux/contract-control-flow').EXIT_CODE;
          ```

          This allows the contract to define the type while the port provides the implementation.

      - type: "pattern"
        summary: "Use timestamps (number) instead of Date objects in contracts"
        detail: |
          WRONG: `retryAfter?: Date` - requires Date constructor, not hermetic
          RIGHT: `retryAfterMs?: number` - pure data, no runtime dependencies

          For FetchError.rateLimited(), accept the timestamp directly:
          ```typescript
          static rateLimited(retryAfterMs?: number): FetchError
          ```

          Callers with access to a clock port compute: `nowMs + delaySeconds * 1000`
          This keeps the contract hermetic (no global Date usage).

      - type: "insight"
        summary: "tsc-reviewer subagent provides thorough automated review"
        detail: |
          The tsc-reviewer subagent performed a comprehensive review covering:
          - Architecture (contract/port separation)
          - Security (no secrets, injection risks)
          - Correctness (logic verification, edge cases)
          - Maintainability (readability, test coverage)
          - Type safety (no any types)

          Verdict was APPROVED with no blockers. This demonstrates the subagent
          can handle rigorous PR review autonomously as required by coding-loop skill.

  - task: "feat/consolidate-error-into-control-flow"
    date: "2025-12-15"
    context: |
      Consolidated @conveaux/contract-error package into @conveaux/port-control-flow.
      The port-control-flow package already had enhanced versions of all error classes
      with intrinsic exit codes and retry metadata, making contract-error redundant.
    learnings:
      - type: "pattern"
        summary: "When consolidating, check for API signature differences"
        detail: |
          The FetchError constructor changed from positional to options object:

          OLD (contract-error): new FetchError(message, statusCode)
          NEW (port-control-flow): new FetchError(message, { statusCode: number })

          All call sites must be updated when migrating to a new API. Search for
          all usages before starting the migration.

      - type: "insight"
        summary: "Abstract base classes still work for instanceof checks"
        detail: |
          ConveauxError changed from a concrete class to an abstract class in
          port-control-flow. The CLI uses `instanceof ConveauxError` to catch
          all domain errors. This still works because:
          1. All concrete error subclasses extend ConveauxError
          2. The prototype chain is properly set with Object.setPrototypeOf

          Abstract classes can serve as instanceof targets for their subclasses.

      - type: "q-and-a"
        summary: "When to consolidate vs keep separate packages"
        detail: |
          Q: When should packages be consolidated?
          A: Consolidate when:
          - One package is a strict superset of another (port-control-flow had
            enhanced versions of all contract-error classes)
          - The separate package adds no unique value
          - Consolidation simplifies the dependency graph

          Keep separate when:
          - Packages serve different purposes (contract vs port)
          - Different consumers need different subsets
          - Circular dependency risk exists

      - type: "insight"
        summary: "Exit codes could improve CLI error handling"
        detail: |
          The tsc-reviewer noted that the CLI could leverage ConveauxError.exitCode
          instead of always using process.exit(1):

          ```typescript
          if (error instanceof ConveauxError) {
            logger.error(error.message, { error });
            process.exit(error.exitCode); // 1=system, 2=user, 3=retryable
          }
          ```

          This is a follow-up improvement opportunity - not part of this refactor.

  - task: "feat/logger-color-config"
    date: "2025-12-15"
    context: |
      Replaced the simple `colors: true/false` API in createPrettyFormatter with a
      flexible color configuration system supporting themes, per-level customization,
      and NO_COLOR/FORCE_COLOR environment variables. Followed contract-port separation.
    learnings:
      - type: "pattern"
        summary: "FORCE_COLOR must be checked before NO_COLOR in resolution order"
        detail: |
          The color resolution order matters. Initial implementation checked NO_COLOR
          before FORCE_COLOR, which meant forceColor couldn't override NO_COLOR.

          WRONG order:
          1. Check NO_COLOR → disable
          2. Check FORCE_COLOR → enable (never reached if NO_COLOR set)

          RIGHT order:
          1. enabled: false → disable
          2. FORCE_COLOR → enable (overrides NO_COLOR)
          3. NO_COLOR → disable
          4. enabled: true → enable
          5. Default → enable

          The key insight: FORCE_COLOR is meant to OVERRIDE NO_COLOR, so it must be
          checked first in the resolution chain.

      - type: "pattern"
        summary: "Injectable ColorEnvironment for testable NO_COLOR detection"
        detail: |
          Instead of reading process.env directly, inject an environment detector:

          ```typescript
          interface ColorEnvironment {
            isNoColorSet: () => boolean;
            isForceColorSet: () => boolean;
            supportsColor: () => boolean;
          }

          function createColorEnvironment(deps: {
            getEnv: (name: string) => string | undefined;
            isTTY?: () => boolean;
          }): ColorEnvironment
          ```

          This allows tests to inject mock environments without touching process.env:
          ```typescript
          const env = createColorEnvironment({
            getEnv: (name) => name === 'NO_COLOR' ? '1' : undefined,
          });
          ```

      - type: "pattern"
        summary: "Use discriminated unions for color specifications"
        detail: |
          For a ColorSpec that can be named colors, 256-color, RGB, or hex:

          ```typescript
          type Ansi256Color = { readonly type: '256'; readonly index: number };
          type RgbColor = { readonly type: 'rgb'; readonly r: number; readonly g: number; readonly b: number };
          type HexColor = { readonly type: 'hex'; readonly value: string };
          type ColorSpec = AnsiColorName | Ansi256Color | RgbColor | HexColor;
          ```

          The `type` discriminant allows type-safe handling:
          ```typescript
          if (typeof spec === 'string') { /* named color */ }
          else if (spec.type === '256') { /* 256-color */ }
          else if (spec.type === 'rgb') { /* RGB */ }
          else if (spec.type === 'hex') { /* hex */ }
          ```

      - type: "insight"
        summary: "plan-writing skill produces thorough API designs"
        detail: |
          Invoking the plan-writing skill before implementation led to:
          - Clear type hierarchy (ColorSpec, StyleDefinition, LoggerTheme, ColorConfig)
          - Proper backward compatibility design (colors: boolean still works)
          - Well-defined resolution order for color enablement
          - Comprehensive test coverage plan

          The "distinguished engineers reviewing" framing helps catch API design
          issues before implementation.

      - type: "pattern"
        summary: "Export ANSI constants for app-level color consistency"
        detail: |
          Export ANSI constants from port-logger so apps don't duplicate them:

          ```typescript
          export const ANSI_COLORS: Record<AnsiColorName, string> = { ... };
          export const ANSI_BG_COLORS: Record<AnsiColorName, string> = { ... };
          export const ANSI_STYLES: Record<AnsiStyle, string> = { ... };
          export const ANSI_RESET = '\x1b[0m';
          ```

          Apps can then import and use consistent color codes:
          ```typescript
          import { ANSI_COLORS, ANSI_RESET } from '@conveaux/port-logger';
          console.log(`${ANSI_COLORS.blue}message${ANSI_RESET}`);
          ```

          This eliminates duplicate ANSI code definitions across the codebase.

  - task: "feat/env-package"
    date: "2025-12-15"
    context: |
      Implemented environment variable management as two packages: contract-env (pure types)
      and port-env (implementation). Provides priority-based conflict resolution between
      multiple env var sources (CLI flags, config files, shell env, defaults). The user
      wanted a fully extensible plugin architecture where consumers register arbitrary
      sources with priorities.
    learnings:
      - type: "pattern"
        summary: "Three-state override semantics are reusable for env var sources"
        detail: |
          The port-id pattern for environment overrides applies to env var management:

          ```typescript
          export type EnvOverrides = Readonly<{
            [key: string]: string | null | undefined;
          }>;
          ```

          Semantics:
          - `undefined`: Key not present in source → fall through to lower priority
          - `null`: Explicitly unset → shadow lower sources (return empty string)
          - `string`: Override value

          Use Object.hasOwn() to distinguish "key not present" from "key set to undefined":
          ```typescript
          if (!Object.hasOwn(overrides, key)) {
            return undefined; // Key not present - fall through
          }
          const value = overrides[key];
          if (value === null) return ''; // Explicit unset - shadow
          return value; // Could be string or undefined
          ```

      - type: "pattern"
        summary: "Priority-based resolution with immutable source composition"
        detail: |
          Sources are registered at factory creation time (immutable composition):

          ```typescript
          const env = createEnv({
            sources: [
              createOverrideEnvSource(cliFlags, { priority: 100 }),
              createStaticEnvSource(profileConfig, { priority: 50 }),
              createShellEnvSource({ getEnv }, { priority: 10 }),
              createStaticEnvSource(defaults, { priority: 0 }),
            ],
          });
          ```

          The factory sorts sources by priority (descending) at creation time.
          First source to return a defined value wins. This is predictable,
          testable, and follows the existing port pattern from port-logger.

      - type: "command-correction"
        summary: "Heredocs in git commit fail in sandbox - use dangerouslyDisableSandbox"
        detail: |
          Git commits using heredoc syntax for multi-line messages fail in sandbox:

          ```
          (eval):1: can't create temp file for here document: operation not permitted
          Aborting commit due to empty commit message.
          ```

          Solution: Use dangerouslyDisableSandbox: true for git commit commands with heredocs.

          This is because heredocs require creating temp files, which sandbox restricts.
          The sandbox restriction is reasonable for security, so this is expected behavior.

      - type: "insight"
        summary: "Explore agents provide comprehensive pattern analysis for planning"
        detail: |
          Launching two parallel Explore agents before planning produced:
          - Complete inventory of all contract/port packages
          - Detailed analysis of factory function patterns (deps, options)
          - Three-state override pattern documentation from port-id
          - ColorEnvironmentDeps pattern documentation from port-logger
          - Existing env handling patterns in claude-code-works

          This comprehensive exploration made the Plan agent's job straightforward
          and resulted in a design that followed established patterns exactly.

  - task: "feat/ephemeral-scheduler"
    date: "2025-12-15"
    context: |
      Created EphemeralScheduler abstraction to replace raw setTimeout/setInterval usage.
      Two packages: contract-ephemeral-scheduler (pure types) and port-ephemeral-scheduler
      (factory implementation). Migrated chatgpt-share to use the new scheduler and deleted
      the old contract-timers package. Also improved validation-pipeline lint error reporting.
    learnings:
      - type: "pattern"
        summary: "Use vi.useFakeTimers() instead of inline fake timer implementations"
        detail: |
          Initial test implementation used complex inline fake timers:

          ```typescript
          function createFakeTimers() {
            const scheduled: Map<number, { callback: () => void; time: number }> = new Map();
            let nextId = 1;
            let currentTime = 0;
            // ... lots of tracking code
          }
          ```

          This is unnecessarily complex. Vitest's fake timers work perfectly with real
          globalThis functions:

          ```typescript
          beforeEach(() => { vi.useFakeTimers(); });
          afterEach(() => { vi.useRealTimers(); });

          function createScheduler() {
            return createEphemeralScheduler({
              setTimeout: globalThis.setTimeout,
              clearTimeout: globalThis.clearTimeout,
              setInterval: globalThis.setInterval,
              clearInterval: globalThis.clearInterval,
            });
          }

          // Advance time with vi.advanceTimersByTime(ms)
          ```

          Benefits: Simpler tests, vitest handles edge cases, consistent with other tests.

      - type: "command-correction"
        summary: "Biome errors go to stderr - combine stdout+stderr for lint output"
        detail: |
          When lint stage fails, showing only stdout misses the actual errors:

          WRONG:
          ```typescript
          const errors = output.stdout.split('\n');
          ```

          RIGHT:
          ```typescript
          const combinedOutput = (output.stdout || '') + (output.stderr || '');
          const errors = extractBiomeErrors(combinedOutput);
          ```

          Biome outputs error details to stderr while summary goes to stdout.
          Always combine both streams when capturing lint tool output.

      - type: "pattern"
        summary: "Use Record<string, never> for empty object types"
        detail: |
          Biome's noBannedTypes rule flags empty object types:

          WRONG:
          ```typescript
          export type EphemeralSchedulerOptions = {};  // noBannedTypes error
          ```

          RIGHT:
          ```typescript
          export type EphemeralSchedulerOptions = Record<string, never>;
          ```

          This explicitly states "an object with no properties" rather than the
          ambiguous `{}` which could mean any object.

      - type: "insight"
        summary: "Keep AbortController and Scheduler as separate concerns"
        detail: |
          Question arose: Should EphemeralScheduler also abstract over AbortController?

          Answer: No - keep them separate for single responsibility:

          - EphemeralScheduler: Time-based scheduling (when to execute)
          - AbortController: Cancellation signaling (how to abort)

          They're often used together but serve different purposes:
          ```typescript
          // Scheduler schedules the abort, but AbortController owns the signal
          const controller = deps.AbortController();
          const timeoutHandle = scheduler.delay(() => controller.abort(), timeout);
          ```

          If AbortController were merged in, we'd have one abstraction doing two things.
          Composition of simple abstractions is better than one complex one.

      - type: "pattern"
        summary: "Extract Biome error patterns for structured lint output"
        detail: |
          Biome outputs errors in format: `./path/to/file.ts:line:col rule_name message`

          Extract these with regex for structured reporting:
          ```typescript
          function extractBiomeErrors(output: string): string[] {
            const lines = output.split('\n');
            const errors: string[] = [];
            for (const line of lines) {
              // Match: ./path:line:col followed by rule
              if (line.match(/^\.\/.+:\d+:\d+\s+\S+/)) {
                errors.push(line.trim());
              }
            }
            return errors;
          }
          ```

          This gives actionable file:line:col locations instead of just "lint failed".

  - task: "feat/zero-dep-html-parser"
    date: "2025-12-15"
    context: |
      Built a zero-dependency HTML parser to replace Cheerio for the chatgpt-share package.
      Created contract-html-parser (interfaces) and port-html-parser (implementation with custom
      tokenizer and DOM builder). Migrated chatgpt-share to use the new parser via DI.
    learnings:
      - type: "command-correction"
        summary: "ID selector regex must allow underscore at start for HTML5 IDs"
        detail: |
          WRONG: `/#([a-zA-Z][a-zA-Z0-9_-]*)/` - only allows letters at start
          RIGHT: `/#([a-zA-Z_-][a-zA-Z0-9_-]*)/` - allows underscore or hyphen at start

          HTML5 IDs like `__NEXT_DATA__` start with underscores. The initial regex only
          matched IDs starting with letters, causing getElementById to fail for the
          primary chatgpt-share use case.

          CSS selectors allow IDs to start with letters, underscores, or hyphens.

      - type: "pattern"
        summary: "Use charAt() instead of bracket access for string indexing in strict TS"
        detail: |
          TypeScript strict mode treats `str[i]` as `string | undefined`, requiring null checks.

          WRONG:
          ```typescript
          const char = remaining[i];  // string | undefined
          if (char === '>') { ... }   // Error: comparison may be undefined
          ```

          RIGHT:
          ```typescript
          const char = remaining.charAt(i);  // string (empty string if out of bounds)
          if (char === '>') { ... }   // Works - empty string !== '>'
          ```

          charAt() returns an empty string for out-of-bounds access, which is falsy and
          fails comparisons cleanly without undefined checks.

      - type: "pattern"
        summary: "Raw content tags need special tokenizer handling"
        detail: |
          Tags like script, style, textarea, and title contain raw text that should NOT
          be tokenized as HTML. After seeing a start tag for these elements, extract
          everything until the closing tag as raw text:

          ```typescript
          const RAW_CONTENT_TAGS = new Set(['script', 'style', 'textarea', 'title']);

          if (RAW_CONTENT_TAGS.has(tagName) && !selfClosing) {
            const closeTagPattern = `</${tagName}>`;
            const closePos = html.toLowerCase().indexOf(closeTagPattern.toLowerCase(), startPos);
            if (closePos !== -1) {
              const rawContent = html.slice(startPos, closePos);
              element.children.push(createTextNode(rawContent));
              // Skip tokens until after close tag
            }
          }
          ```

          This preserves JSON in script tags, CSS in style tags, etc.

      - type: "insight"
        summary: "Zero-dependency HTML parsers are feasible for targeted use cases"
        detail: |
          Cheerio (1.0.0) adds ~200KB to bundle and has 9 dependencies. For chatgpt-share,
          only these features were needed:
          - getElementById (find script tag)
          - innerHTML (get JSON content)

          A custom parser (~500 lines) replaced Cheerio entirely:
          - Tokenizer: doctypes, start/end/self-closing tags, text, comments, entities
          - DOM builder: tree construction from tokens
          - Selector parser: tag, #id, .class, [attr] basics

          Key insight: Evaluate actual feature usage before assuming heavyweight libraries
          are necessary. The contract-port pattern made this migration low-risk - contract
          defines full API, implementation can grow progressively.

      - type: "pattern"
        summary: "HTML entity decoding only needs basics for JSON-in-script scenarios"
        detail: |
          For extracting JSON from script tags, minimal entity decoding suffices:

          ```typescript
          function decodeHtmlEntities(text: string): string {
            return text
              .replace(/&amp;/g, '&')
              .replace(/&lt;/g, '<')
              .replace(/&gt;/g, '>')
              .replace(/&quot;/g, '"')
              .replace(/&#39;|&apos;/g, "'")
              .replace(/&#(\d+);/g, (_, n) => String.fromCodePoint(parseInt(n, 10)))
              .replace(/&#x([0-9a-fA-F]+);/g, (_, hex) => String.fromCodePoint(parseInt(hex, 16)));
          }
          ```

          HTML5 defines 2,231 named entities, but JSON content only uses these basics.
          The implementation can grow to support more entities when consumers need them.

      - type: "misconception"
        summary: "Cheerio wrappers are not the path to zero dependencies"
        detail: |
          WRONG: Create a CheerioBackend adapter to abstract over Cheerio
          RIGHT: Build custom tokenizer and DOM builder from scratch

          Initial approach was to create a backend abstraction that could use Cheerio
          or other libraries. User feedback: "createCheerioBackend is a bad approach.
          We don't care about keeping compatibility with cheerio. We want to avoid it."

          The goal was zero external dependencies, not library abstraction. The
          contract-port pattern works better with a custom implementation that can
          grow in capability over time.
